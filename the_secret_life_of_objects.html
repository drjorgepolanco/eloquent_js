<html>
<head>
  <title>The Secret Life of Objects</title>
</head>
<body>
<script type="text/javascript">

  // THE SECRET LIFE OF OBJECTS
  // ==========================
  
  // --------------------------------------------------------------------------
  // Methods
  // -------

  var rabbit = {};
  rabbit.speak = function(line) {
    console.log("The rabbit says '" + line + "'");
  };
  rabbit.speak("I'm alive!"); 
  // → The rabbit says 'I'm alive!'


  // 'this' points to the object it was called on.
  function speak(line) {
    console.log("The " + this.type + " rabbit says '" + line + "'");
  };
  var whiteRabbit = {type: "white", speak: speak};
  var fatRabbit = {type: "fat", speak: speak};

  whiteRabbit.speak("Oh my ears and whiskers, " + "how late it's getting!");
  // → The white rabbit says 'Oh my ears and whiskers, how late it's getting!'

  fatRabbit.speak("I could sure use a carrot right now.");
  // → The fat rabbit says 'I could sure use a carrot right now.'

  speak.apply(fatRabbit, ["burp!"]);
  // → The fat rabbit says 'burp!'

  speak.call({type: "old"}, "Oh my...");
  // → The old rabbit says 'Oh my...'
  
  // --------------------------------------------------------------------------
  // Prototypes
  // ----------

  var protoRabbit = {
    speak: function(line) {
      console.log("The " + this.type + " rabbit says '" + line + "'");
    }
  };
  var killerRabbit = Object.create(protoRabbit);
  killerRabbit.type = "killer";
  killerRabbit.speak("SKREEEEE!!!");
  // → The killer rabbit says 'SKREEEEE!!!'

  // --------------------------------------------------------------------------
  // Constructors
  // ------------

  function Rabbit(type) {
    this.type = type;
  };

  var killerRabbit = new Rabbit("killer");
  var blackRabbit = new Rabbit("black");
  console.log(blackRabbit.type);
  // → black

  Rabbit.prototype.speak = function(line) {
    console.log("The " + this.type + " rabbit says '" + line + "'");
  };
  blackRabbit.speak("Doom...");
  // → The black rabbit says 'Doom...'

  // --------------------------------------------------------------------------
  // Overriding Derived Properties
  // -----------------------------

  Rabbit.prototype.teeth = "small";
  console.log(killerRabbit.teeth);
  // → small
  killerRabbit.teeth = "long, sharp, and bloody";
  console.log(killerRabbit.teeth);
  // → long, sharp, and bloody
  console.log(blackRabbit.teeth);
  // → small
  console.log(Rabbit.prototype.teeth);
  // → small

  // Calling toString() on an array gives a result similar to calling .join(",")
  // on it - it puts commas between the values in the array. But directly calling
  // Object.prototype.toString with an array produces a different string.

  console.log(Array.prototype.toString == Object.prototype.toString);
  // → false
  console.log([1, 2].toString());
  // → 1, 2

  console.log(Object.prototype.toString.call([1, 2]));
  // → [object Array]

  // --------------------------------------------------------------------------
  // Prototype Interference
  // ----------------------

  // A prototype can be used at any time to add new properties and methods to 
  // all objects based on it.

  Rabbit.prototype.dance = function() {
    console.log("The " + this.type + " rabbit dances a jig.");
  };
  killerRabbit.dance();
  // → The killer rabbit dances a jig.
  
  // That's convenient, but there are situations where it causes problems. In
  // previous chapters, we used objects as a way to associate values with names.
  var map = {};
  function storePhi(event, phi) {
    map[event] = phi;
  };
  storePhi("pizza", 0.069);
  storePhi("touched tree", -0.081);

  // We can iterate over all phi values in the object using a for/in loop and
  // test whether a name is in there using the regular in operator. But unfortunately,
  // the object's prototype gets in the way.
  Object.prototype.nonsense = "hi!";
  for (var name in map) {
    console.log(name);
  };
  // → pizza
  // → touched tree
  // → nonsense
  console.log("nonsense" in map);
  // → true
  console.log("toString" in map);
  // → true

  // Delete the problematic property again
  delete Object.prototype.nonsense;

  // But why? Why are we getting true even though there is no 'nonsense' or 
  // 'toString' event in our data set?

  // Because JavaScript distinguishes between 'enumerable' and 'nonenumerable' 
  // properties.

  // 'enumerable'    are all properties we create by simply assigning to them.
  // 'nonenumerable' are the standard properties in Object.prototype.

  // To define our own nonenumerable properties we use 'Object.defineProperty()'
  Object.defineProperty(Object.prototype, "hiddenNonsense", 
                        {enumerable: false, value: "hi"});
  for (var name in map) {
    console.log(name);
  };
  // → pizza
  // → touched tree
  console.log(map.hiddenNonsense);
  // → hi

  // We still have the problem with the regular 'in' operator who claims that the
  // Object.prototype properties exist in our object. In this case we use:
  console.log(map.hasOwnProperty("toString"));
  // → false

  // 'hasOwnProperty' tells us whether the object itself has the property, without 
  // looking at its prototypes. 

  // If you think some code loaded in your program might have messed with the base
  // object prototype, write the for/in loops like this:
  for (var name in map) {
    if (map.hasOwnProperty(name)) {
      // ... this is an own property
    }
  };

  // --------------------------------------------------------------------------
  // Prototype-less Objects
  // ----------------------

  // To create a fresh object with no prototype, pass null as the prototype:
  var map = Object.create(null);
  map["pizza"] = 0.069;
  console.log("toString" in map);
  // → false
  console.log("pizza" in map);
  // → true
  
  // Much better! We no longer need the hasOwnProperty kludge because all the 
  // properties the object has are its own properties. Now we can safely use 
  // for/in loops.

  // --------------------------------------------------------------------------
  // Polymorphism
  // ------------

  // Laying out a Table


  // name         height country
  // ------------ ------ -------------
  // Kilimanjaro    5895 Tanzania
  // Everest        8848 Nepal
  // Mount Fuji     3776 Japan
  // Mont Blanc     4808 Italy/France
  // Vaalserberg     323 Netherlands
  // Denali         6168 United States
  // Popocatepetl   5465 Mexico

  // minHeight()         returns a number indicating the minimum height this cell 
  //                     requires (in lines).
  // minWidth()          returns a number indicating this cell's minimum width 
  //                     (in characters).
  // draw(width, height) returns an array of length height, which contains a
  //                     series of strings that are each width characters wide.
  //                     This represents the content of the cell.

  // Computes arrays of minimum column widths and row heights for a grid of cells.
  function rowHeights(rows) {
    return rows.map(function(row) {
      return row.reduce(function(max, cell) {
        return Math.max(max, cell.minHeight());
      }, 0);
    });
  };

  function colWidths(rows) {
    return rows[0].map(function(_, i) {
      return rows.reduce(function(max, row) {
        return Math.max(max, row[i].minWidth());
      }, 0);
    });
  };

</script>
</body>
</html>